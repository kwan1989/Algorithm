package programmers;

import java.util.Arrays;

public class 이분탐색_입국심사 {

    /**
     * https://programmers.co.kr/learn/courses/30/lessons/43238?language=java
     *
     *
     * 문제 설명
     * n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다.
     * 처음에 모든 심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다.
     * 모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다.
     * 입국심사를 기다리는 사람 수 n, 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times가 매개변수로 주어질 때, 모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요.
     *
     * 제한사항
     * 입국심사를 기다리는 사람은 1명 이상 1,000,000,000명 이하입니다.
     * 각 심사관이 한 명을 심사하는데 걸리는 시간은 1분 이상 1,000,000,000분 이하입니다.
     * 심사관은 1명 이상 100,000명 이하입니다.
     *
     * 입출력 예
     * n	times	return
     * 6	[7, 10]	28
     *
     * 입출력 예 설명
     * 가장 첫 두 사람은 바로 심사를 받으러 갑니다.
     *
     * 7분이 되었을 때, 첫 번째 심사대가 비고 3번째 사람이 심사를 받습니다.
     * 10분이 되었을 때, 두 번째 심사대가 비고 4번째 사람이 심사를 받습니다.
     * 14분이 되었을 때, 첫 번째 심사대가 비고 5번째 사람이 심사를 받습니다.
     * 20분이 되었을 때, 두 번째 심사대가 비지만 6번째 사람이 그곳에서 심사를 받지 않고 1분을 더 기다린 후에 첫 번째 심사대에서 심사를 받으면 28분에 모든 사람의 심사가 끝납니다.
     *
     * 테스트 1 〉	통과 (16.85ms, 53.5MB)
     * 테스트 2 〉	통과 (16.95ms, 53.1MB)
     * 테스트 3 〉	통과 (25.05ms, 53.7MB)
     * 테스트 4 〉	통과 (147.78ms, 61.8MB)
     * 테스트 5 〉	통과 (99.74ms, 60.3MB)
     * 테스트 6 〉	통과 (92.84ms, 60.1MB)
     * 테스트 7 〉	통과 (131.97ms, 60.8MB)
     * 테스트 8 〉	통과 (134.62ms, 61.1MB)
     * 테스트 9 〉	통과 (20.84ms, 53.7MB)
     *
     */
    public long solution(int n, int[] times) {
        return binarySearch(n, times);
    }



    /**
     * 이진탐색
     * 각 심사관의 카운터의 합산이 최소시간이 되는 기점을 찾는다.
     *
     * @param n     입국심사를 기다리는 사람 수 n
     * @param times 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times
     * @return 모든 사람이 심사를 받는데 걸리는 시간의 최소값
     */
    public long binarySearch(int n, int[] times) {

        long result = 0;

        // 이진 탐색은 정렬된 데이터로 부터
        Arrays.sort(times);

        /**
         * 이진탐색의 범위
         * left(min) 은 항상 1 부터 시작
         * right(max) 는 최대 범위인 [인원수] * [가장 오래걸리는 심사관] 으로 최대 값을 잡아주었다.
         *
         * ★ 여기서 주의 해야할 점은 (long)n * times[times.length - 1] 부분으로 (long) 선언을 잡아주지 않아서 애를 먹었다.
         * ★ (도움을 주신 잡부님에게 감사드립니다.)
         * ★ (자극을 주신 강서님에게 감사드립니다.)
         */
        long left = 1, mid = 0, right = (long)n * times[times.length - 1];

        /**
         * 중간의 이분탐색 mid 값이 최대값보다 커지면 종료 (최소/중간/최대/카운터)
         *
         * Cycle 1 : [01]    ~   [30]    ~   [60]    7      |     ■□□□□□□□□□□□■□□□□□□□□□□□■
         * Cycle 2 : [01]    ~   [15]    ~   [29]    3      |     ■□□□□□■□□□□□■□□□□□□□□□□□□
         * Cycle 3 : [16]    ~   [22]    ~   [29]    5      |     □□□□□□■□□■□□■□□□□□□□□□□□□
         * Cycle 4 : [23]    ~   [26]    ~   [29]    5      |     □□□□□□□□□□■■■□□□□□□□□□□□□
         * Cycle 5 : [27]    ~   [28]    ~   [29]    7      |     □□□□□□□□□□□■□□□□□□□□□□□□□
         *
         * 이후 다음 동작시 right = mid - 1 이 되기 때문에 빠져나오게 된다.
         */
        while (left <= right) {

            // 이분탐색의 중간 값 계산
            mid = (left + right) / 2;

            // 심사관의 심사횟수 합계
            long cnt = processCnt(mid, times, n);

            //System.out.println("left/mid/right/sum : " + left + " ~ " + mid + " ~ " + right + " / " + cnt);

            // 탐색 범위 이분 탐색
            if (cnt < n) {
                // 누적 값이 더 작은 경우 left 를 늘린다.
                left = mid + 1;
            } else  {
                // 누적 값이 더 클 경우 right 를 줄인다.
                right = mid - 1;

                // 추후 결과 데이터
                result = mid;
            }
        }
        return result;
    }



    /**
     * 심사관의 심사 카운터 합계를 반환
     * @param mid 이분탐색 중간 값
     * @param times 각 심사관들의 심사 시간
     * @param n 대기 인원수
     * @return 심사 카운터 합계
     */
    private long processCnt(long mid, int[] times, int n) {
        long sum = 0;
        for (int time : times) {

            // 면접관 마다 몇명의 심사 진행 가능한지
            sum += mid / time;

            // sum 이 n 을 넘어서면 카운터는 의미없다. (시간단축용)
            if (sum > n)
                break;
        }
        return sum;
    }

}
